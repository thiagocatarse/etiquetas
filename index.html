<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shipping Label Generator</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; }
        .container { max-width: 600px; margin: auto; }
        h1 { text-align: center; }
        #file-input, #template-select { margin: 20px 0; width: 100%; }
        #generate-btn { display: block; margin: 20px auto; padding: 10px 20px; }
        #status { text-align: center; color: #666; font-style: italic; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Shipping Label Generator</h1>
        <select id="template-select">
            <option value="">Select a template...</option>
        </select>
        <input type="file" id="file-input" accept=".csv">
        <button id="generate-btn">Generate Labels</button>
        <p id="status"></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const fileInput = document.getElementById('file-input');
        const templateSelect = document.getElementById('template-select');
        const generateBtn = document.getElementById('generate-btn');
        const statusElement = document.getElementById('status');

        let processedData = null;
        let selectedTemplate = null;
        let inactivityTimer;
        const INACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 minutes

        const templates = [
            "3080", "3081", "3082", "3180", "3181", "3182", "5580A", "5580M", "5580V", "6080",
            "6081", "6082", "6083", "6084", "6085", "6086", "6087", "6088", "6089", "6092",
            "6093", "6094", "6095", "6180", "6181", "6182", "6183", "6184", "6185", "6187",
            "6280", "6281", "6282", "6283", "6284", "6285", "6286", "6287", "6288", "6293",
            "7088", "7089", "7188", "8096", "8098", "8099F", "8099L", "8196", "8296", "62580",
            "62581", "62582", "A4048", "A4049", "A4050", "A4051", "A4054", "A4054R", "A4055",
            "A4056", "A4056R", "A4060", "A4062", "A4063", "A4063R", "A4067", "A4248", "A4249",
            "A4250", "A4251", "A4254", "A4255", "A4256", "A4260", "A4261", "A4262", "A4263",
            "A4264", "A4265", "A4267", "A4268", "A4348", "A4349", "A4350", "A4351", "A4354",
            "A4355", "A4356", "A4360", "A4361", "A4362", "A4363", "A4364", "A4365", "A4367",
            "A4368", "BOOP100x40"
        ];

        // Populate template select options
        templates.forEach(template => {
            const option = document.createElement('option');
            option.value = template;
            option.textContent = template;
            templateSelect.appendChild(option);
        });

        generateBtn.addEventListener('click', generateLabels);
        templateSelect.addEventListener('change', loadTemplate);

        // Set up event listeners for automatic clearing
        window.addEventListener('beforeunload', clearData);
        document.addEventListener('mousemove', resetInactivityTimer);
        document.addEventListener('keypress', resetInactivityTimer);

        function loadTemplate() {
            const templateId = templateSelect.value;
            if (!templateId) {
                setStatus('Please select a template.', 'error');
                return;
            }

            fetch(`TEMPLATES/${templateId}.json`)
                .then(response => response.json())
                .then(data => {
                    selectedTemplate = data;
                    setStatus('Template loaded successfully.', 'success');
                })
                .catch(error => {
                    console.error('Error loading template:', error);
                    setStatus('Error loading template. Please try again.', 'error');
                });
        }

        function generateLabels() {
            if (!selectedTemplate) {
                setStatus('Please select a template first.', 'error');
                return;
            }

            const file = fileInput.files[0];
            if (!file) {
                setStatus('Please select a CSV file.', 'error');
                return;
            }

            Papa.parse(file, {
                complete: function(results) {
                    if (validateCSV(results.data)) {
                        processedData = processCSV(results.data);
                        generatePDF(processedData, selectedTemplate);
                        setTimeout(() => {
                            clearData();
                            setStatus('Labels generated and data cleared.', 'success');
                        }, 1000);
                    } else {
                        setStatus('Invalid CSV format. Please check your file and try again.', 'error');
                    }
                }
            });
        }

        function validateCSV(data) {
            if (data.length < 2) return false; // At least header row and one data row

            const requiredHeaders = ['Nome completo', 'Rua', 'Número', 'Complemento', 'Bairro', 'Cidade', 'Estado', 'País', 'CEP', 'Título da recompensa'];
            const headers = data[0];

            return requiredHeaders.every(header => headers.includes(header));
        }

        function processCSV(data) {
            const headers = data[0];
            return data.slice(1).map(row => {
                const backer = {};
                headers.forEach((header, index) => {
                    backer[header] = row[index] ? row[index].trim() : '';
                });
                return backer;
            });
        }

        function generatePDF(backers, template) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: template.page.orientation,
                unit: template.page.unit,
                format: template.page.size
            });

            const pageWidth = parseFloat(template.page.size[0]);
            const pageHeight = parseFloat(template.page.size[1]);
            const marginTop = parseFloat(template.page['margin-top']);
            const marginLeft = parseFloat(template.page['margin-left']);
            const labelWidth = parseFloat(template.tag.width);
            const labelHeight = parseFloat(template.tag.height);
            const labelsPerLine = parseInt(template.page.columns);
            let fontSize = parseFloat(template.page['font-size']);
            let lineHeight = fontSize * 1.1;

            doc.setFontSize(fontSize);

            function wrapText(text, maxWidth) {
                const words = text.split(' ');
                let lines = [];
                let currentLine = words[0];

                for (let i = 1; i < words.length; i++) {
                    let width = doc.getStringUnitWidth(currentLine + ' ' + words[i]) * fontSize / doc.internal.scaleFactor;
                    if (width < maxWidth) {
                        currentLine += ' ' + words[i];
                    } else {
                        lines.push(currentLine);
                        currentLine = words[i];
                    }
                }
                lines.push(currentLine);
                return lines;
            }

            function addTextToLabel(text, x, y, maxWidth, maxLines) {
                const lines = wrapText(text, maxWidth);
                for (let i = 0; i < Math.min(lines.length, maxLines); i++) {
                    doc.text(lines[i], x, y + i * lineHeight);
                }
                return Math.min(lines.length, maxLines) * lineHeight;
            }

            backers.forEach((backer, i) => {
                if (i > 0 && i % (labelsPerLine * Math.floor((pageHeight - 2 * marginTop) / labelHeight)) === 0) {
                    doc.addPage();
                }

                const row = Math.floor((i % (labelsPerLine * Math.floor((pageHeight - 2 * marginTop) / labelHeight))) / labelsPerLine);
                const col = i % labelsPerLine;

                const x = marginLeft + col * labelWidth + parseFloat(template.tag['margin-left']);
                const y = marginTop + row * labelHeight;

                if (template.tag.border !== "0") {
                    doc.rect(x, y, labelWidth, labelHeight);
                }

                let yOffset = 2;

                // Add name
                yOffset += addTextToLabel(`Nome: ${backer['Nome completo']}`, x + 2, y + yOffset, labelWidth - 4, 2);

                // Add address
                const address = `${backer['Rua']} ${backer['Número']} ${backer['Complemento']} - ${backer['Bairro']} - ${backer['Cidade']} - ${backer['Estado']} - ${backer['País']} - CEP ${backer['CEP']}`;
                yOffset += addTextToLabel(address, x + 2, y + yOffset, labelWidth - 4, 5);

                // Add reward at the bottom of the label
                const rewardY = y + labelHeight - lineHeight - 2;
                addTextToLabel(`Recompensa: ${backer['Título da recompensa']}`, x + 2, rewardY, labelWidth - 4, 2);

                // Check if content fits and reduce font size if necessary
                if (yOffset > labelHeight - lineHeight * 3) {
                    fontSize *= 0.9;
                    lineHeight = fontSize * 1.1;
                    doc.setFontSize(fontSize);
                    // Recalculate label content (you'd need to adjust this part)
                }
            });

            doc.save('shipping_labels.pdf');
        }

        function clearData() {
            fileInput.value = '';
            processedData = null;
            selectedTemplate = null;
            templateSelect.value = '';
            if (window.gc) {
                window.gc();
            }
            console.log('Data has been cleared from memory.');
        }

        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(() => {
                clearData();
                setStatus('Data cleared due to inactivity.', 'info');
            }, INACTIVITY_TIMEOUT);
        }

        function setStatus(message, type) {
            statusElement.textContent = message;
            statusElement.style.color = type === 'error' ? 'red' : type === 'success' ? 'green' : '#666';
        }

        // Initial setup of inactivity timer
        resetInactivityTimer();
    });
    </script>
</body>
</html>